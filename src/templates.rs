use crate::config::Config;
use colored::*;
use eyre::{Context, Result};
use std::fs;
use std::path::Path;

pub fn generate_project(
    project_name: &str,
    target_dir: &Path,
    author: &str,
    config: &Config,
    include_deps: bool,
) -> Result<()> {
    // Create src directory
    let src_dir = target_dir.join("src");
    fs::create_dir_all(&src_dir).context("Failed to create src directory")?;

    // Generate Cargo.toml
    generate_cargo_toml(project_name, target_dir, author, config, include_deps)?;

    // Generate build.rs
    generate_build_rs(target_dir)?;

    // Generate source files
    generate_main_rs(project_name, &src_dir)?;
    generate_cli_rs(project_name, &src_dir)?;
    generate_config_rs(&src_dir)?;

    // Generate sample config file
    generate_sample_config(project_name, target_dir)?;

    // Generate .otto.yml for CI
    generate_otto_yml(project_name, target_dir)?;

    println!("{} Generated all project files", "‚úì".green());
    Ok(())
}

fn generate_cargo_toml(
    project_name: &str,
    target_dir: &Path,
    author: &str,
    config: &Config,
    include_deps: bool,
) -> Result<()> {
    let mut cargo_toml = format!(
        r#"[package]
name = "{}"
version = "0.1.0"
edition = "2024"
authors = ["{}"]
build = "build.rs"
description = "A CLI application generated by rust-scaffold"

[dependencies]"#,
        project_name, author
    );

    if include_deps {
        // Add dependencies directly to Cargo.toml
        for dep in &config.template.dependencies {
            if dep.features.is_empty() {
                cargo_toml.push_str(&format!("\n{} = \"*\"", dep.name));
            } else {
                cargo_toml.push_str(&format!(
                    "\n{} = {{ version = \"*\", features = [{}] }}",
                    dep.name,
                    dep.features
                        .iter()
                        .map(|f| format!("\"{}\"", f))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
            }
        }
    } else {
        cargo_toml.push_str("\n# Dependencies will be added via cargo add");
    }

    cargo_toml.push_str("\n\n[build-dependencies]\n# For build.rs if needed\n");

    fs::write(target_dir.join("Cargo.toml"), cargo_toml).context("Failed to write Cargo.toml")?;

    Ok(())
}

fn generate_build_rs(target_dir: &Path) -> Result<()> {
    let build_rs = r#"// Simple pattern for git describe -> version
use std::process::Command;

fn main() {
    let git_describe = Command::new("git")
        .args(["describe", "--tags", "--always"])
        .output()
        .and_then(|output| {
            if output.status.success() {
                Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
            } else {
                Err(std::io::Error::other("git describe failed"))
            }
        })
        .unwrap_or_else(|_| {
            // Fallback to Cargo.toml version when git describe fails
            env!("CARGO_PKG_VERSION").to_string()
        });

    println!("cargo:rustc-env=GIT_DESCRIBE={}", git_describe);
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/");
}
"#;

    fs::write(target_dir.join("build.rs"), build_rs).context("Failed to write build.rs")?;

    Ok(())
}

fn generate_main_rs(project_name: &str, src_dir: &Path) -> Result<()> {
    let main_rs = format!(
        r#"use clap::Parser;
use colored::*;
use eyre::{{Context, Result}};
use log::info;
use std::fs;
use std::path::PathBuf;

mod cli;
mod config;

use cli::Cli;
use config::Config;

fn setup_logging() -> Result<()> {{
    // Create log directory
    let log_dir = dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("{}")
        .join("logs");

    fs::create_dir_all(&log_dir).context("Failed to create log directory")?;

    let log_file = log_dir.join("{}.log");

    // Setup env_logger with file output
    let target = Box::new(
        fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&log_file)
            .context("Failed to open log file")?,
    );

    env_logger::Builder::from_default_env()
        .target(env_logger::Target::Pipe(target))
        .init();

    info!("Logging initialized, writing to: {{}}", log_file.display());
    Ok(())
}}

fn run_application(_cli: &Cli, config: &Config) -> Result<()> {{
    info!("Starting application");

    // Load and display configuration
    println!("{{}}", "‚úì Configuration loaded successfully".green());
    if config.debug {{
        println!("{{}}", "üîç Debug mode enabled".yellow());
    }}

    // Demonstrate colored output
    println!("{{}} Hello from {{}}!", "üéâ".green(), "{}".cyan());
    println!("{{}} Author: {{}}", "üë§".blue(), config.name);
    println!("{{}} Age: {{}}", "üìÖ".blue(), config.age);

    // Log some information
    info!("Application executed successfully");

    Ok(())
}}

fn main() -> Result<()> {{
    // Setup logging first
    setup_logging().context("Failed to setup logging")?;

    // Parse CLI arguments
    let cli = Cli::parse();

    // Load configuration
    let config = Config::load(cli.config.as_ref()).context("Failed to load configuration")?;

    info!("Starting with config from: {{:?}}", cli.config);

    // Run the main application logic
    run_application(&cli, &config).context("Application failed")?;

    Ok(())
}}
"#,
        project_name, project_name, project_name
    );

    fs::write(src_dir.join("main.rs"), main_rs).context("Failed to write main.rs")?;

    Ok(())
}

fn generate_cli_rs(project_name: &str, src_dir: &Path) -> Result<()> {
    let cli_rs = format!(
        r#"use clap::Parser;
use std::path::PathBuf;

#[derive(Parser)]
#[command(
    name = "{}",
    about = "A CLI application generated by rust-scaffold",
    version = env!("GIT_DESCRIBE"),
    after_help = "Logs are written to: ~/.local/share/{}/logs/{}.log"
)]
pub struct Cli {{
    /// Path to config file
    #[arg(short, long, help = "Path to config file")]
    pub config: Option<PathBuf>,

    /// Enable verbose output
    #[arg(short, long, help = "Enable verbose output")]
    pub verbose: bool,
}}
"#,
        project_name, project_name, project_name
    );

    fs::write(src_dir.join("cli.rs"), cli_rs).context("Failed to write cli.rs")?;

    Ok(())
}

fn generate_config_rs(src_dir: &Path) -> Result<()> {
    let config_rs = r#"use eyre::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Deserialize, Serialize)]
#[serde(default)]
pub struct Config {
    pub name: String,
    pub age: u32,
    pub debug: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            name: "John Doe".to_string(),
            age: 30,
            debug: false,
        }
    }
}

impl Config {
    /// Load configuration with fallback chain
    pub fn load(config_path: Option<&PathBuf>) -> Result<Self> {
        // If explicit config path provided, try to load it
        if let Some(path) = config_path {
            return Self::load_from_file(path).context(format!("Failed to load config from {}", path.display()));
        }

        // Try primary location: ~/.config/<project>/<project>.yml
        if let Some(config_dir) = dirs::config_dir() {
            let project_name = env!("CARGO_PKG_NAME");
            let primary_config = config_dir.join(project_name).join(format!("{}.yml", project_name));
            if primary_config.exists() {
                match Self::load_from_file(&primary_config) {
                    Ok(config) => return Ok(config),
                    Err(e) => {
                        log::warn!("Failed to load config from {}: {}", primary_config.display(), e);
                    }
                }
            }
        }

        // Try fallback location: ./<project>.yml
        let project_name = env!("CARGO_PKG_NAME");
        let fallback_config = PathBuf::from(format!("{}.yml", project_name));
        if fallback_config.exists() {
            match Self::load_from_file(&fallback_config) {
                Ok(config) => return Ok(config),
                Err(e) => {
                    log::warn!("Failed to load config from {}: {}", fallback_config.display(), e);
                }
            }
        }

        // No config file found, use defaults
        log::info!("No config file found, using defaults");
        Ok(Self::default())
    }

    fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = fs::read_to_string(&path).context("Failed to read config file")?;

        let config: Self = serde_yaml::from_str(&content).context("Failed to parse config file")?;

        log::info!("Loaded config from: {}", path.as_ref().display());
        Ok(config)
    }
}
"#;

    fs::write(src_dir.join("config.rs"), config_rs).context("Failed to write config.rs")?;

    Ok(())
}

fn generate_sample_config(project_name: &str, target_dir: &Path) -> Result<()> {
    let sample_config = format!(
        r#"# {}.yml - Sample configuration file
name: "John Doe"
age: 30
debug: false
"#,
        project_name
    );

    fs::write(target_dir.join(format!("{}.yml", project_name)), sample_config)
        .context("Failed to write sample config")?;

    Ok(())
}

fn generate_otto_yml(_project_name: &str, target_dir: &Path) -> Result<()> {
    let otto_yml = r#"otto:
  api: 1
  tasks: [ci]
  envs:
    VERSION: "$(git describe --tags --always --dirty 2>/dev/null || echo 'dev')"

tasks:
  # Whitespace linting
  lint:
    help: "Run whitespace linting"
    bash: |
      whitespace -r

  # Code quality checks
  check:
    help: "Run all quality checks (compile, clippy, format)"
    bash: |
      echo "=== Checking compilation ==="
      cargo check --all-targets --all-features
      echo ""
      echo "=== Running Clippy ==="
      cargo clippy --all-targets --all-features -- -D warnings
      echo ""
      echo "=== Checking format ==="
      cargo fmt --all --check
      echo ""
      echo "‚úÖ All checks passed!"

  # Run tests
  test:
    help: "Run all tests"
    bash: |
      cargo test --all-features

  # Code coverage with llvm-cov
  cov:
    help: "Run tests with coverage via llvm-cov (use --fail-under N for threshold)"
    params:
      --fail-under:
        default: "0"
        help: "Minimum line coverage percentage (0 = no threshold)"
    bash: |
      echo "üß™ Running tests with coverage..."
      if [ "${fail_under}" != "0" ]; then
        if cargo llvm-cov --all-features --html -q --fail-under-lines "${fail_under}"; then
          echo ""
          echo "‚úÖ Coverage meets ${fail_under}% threshold"
          echo "üìä Coverage report: target/llvm-cov/html/index.html"
        else
          echo ""
          echo "‚ùå Coverage is below ${fail_under}% threshold"
          echo "üìä Coverage report: target/llvm-cov/html/index.html"
          exit 1
        fi
      else
        cargo llvm-cov --all-features --html -q
        echo ""
        echo "‚úÖ Coverage report: target/llvm-cov/html/index.html"
      fi

  # Full CI pipeline
  ci:
    help: "Full CI pipeline (lint + check + test in parallel)"
    before: [lint, check, test]
    bash: |
      echo "‚úÖ All CI checks passed!"

  # Build release binary
  build:
    help: "Build release binary"
    bash: |
      cargo build --release
      echo "‚úÖ Release build complete"

  # Clean build artifacts
  clean:
    help: "Clean build artifacts"
    bash: |
      cargo clean
      echo "‚úÖ Build artifacts cleaned"

  # Install locally
  install:
    help: "Install binary locally via cargo"
    bash: |
      cargo install --path .
      echo "‚úÖ Binary installed to ~/.cargo/bin"

"#;

    fs::write(target_dir.join(".otto.yml"), otto_yml).context("Failed to write .otto.yml")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    fn create_test_config() -> Config {
        Config::default()
    }

    #[test]
    fn test_generate_project_creates_all_files() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-project";
        let author = "Test Author <test@example.com>";
        let config = create_test_config();

        let result = generate_project(project_name, temp_dir.path(), author, &config, false);
        assert!(result.is_ok());

        // Check that all expected files were created
        assert!(temp_dir.path().join("Cargo.toml").exists());
        assert!(temp_dir.path().join("build.rs").exists());
        assert!(temp_dir.path().join("src").exists());
        assert!(temp_dir.path().join("src/main.rs").exists());
        assert!(temp_dir.path().join("src/cli.rs").exists());
        assert!(temp_dir.path().join("src/config.rs").exists());
        assert!(temp_dir.path().join(format!("{}.yml", project_name)).exists());
    }

    #[test]
    fn test_generate_cargo_toml_basic_structure() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-cargo";
        let author = "Test Author <test@example.com>";
        let config = create_test_config();

        let result = generate_cargo_toml(project_name, temp_dir.path(), author, &config, false);
        assert!(result.is_ok());

        let cargo_toml = fs::read_to_string(temp_dir.path().join("Cargo.toml")).unwrap();

        assert!(cargo_toml.contains(&format!("name = \"{}\"", project_name)));
        assert!(cargo_toml.contains("version = \"0.1.0\""));
        assert!(cargo_toml.contains("edition = \"2024\""));
        assert!(cargo_toml.contains(author));
        assert!(cargo_toml.contains("build = \"build.rs\""));
        assert!(cargo_toml.contains("[dependencies]"));
        assert!(cargo_toml.contains("[build-dependencies]"));
    }

    #[test]
    fn test_generate_cargo_toml_with_dependencies() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-deps";
        let author = "Test Author";
        let config = create_test_config();

        let result = generate_cargo_toml(project_name, temp_dir.path(), author, &config, true);
        assert!(result.is_ok());

        let cargo_toml = fs::read_to_string(temp_dir.path().join("Cargo.toml")).unwrap();

        // Check that dependencies are included
        assert!(cargo_toml.contains("clap"));
        assert!(cargo_toml.contains("eyre"));
        assert!(cargo_toml.contains("serde"));
        assert!(cargo_toml.contains("derive"));
    }

    #[test]
    fn test_generate_cargo_toml_without_dependencies() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-no-deps";
        let author = "Test Author";
        let config = create_test_config();

        let result = generate_cargo_toml(project_name, temp_dir.path(), author, &config, false);
        assert!(result.is_ok());

        let cargo_toml = fs::read_to_string(temp_dir.path().join("Cargo.toml")).unwrap();

        // Check that dependencies comment is included instead
        assert!(cargo_toml.contains("Dependencies will be added via cargo add"));
        assert!(!cargo_toml.contains("clap = "));
        assert!(!cargo_toml.contains("eyre = "));
    }

    #[test]
    fn test_generate_build_rs() {
        let temp_dir = TempDir::new().unwrap();

        let result = generate_build_rs(temp_dir.path());
        assert!(result.is_ok());

        let build_rs = fs::read_to_string(temp_dir.path().join("build.rs")).unwrap();

        assert!(build_rs.contains("fn main()"));
        assert!(build_rs.contains("git describe"));
        assert!(build_rs.contains("GIT_DESCRIBE"));
        assert!(build_rs.contains("cargo:rerun-if-changed=.git/HEAD"));
        assert!(build_rs.contains("cargo:rerun-if-changed=.git/refs/"));
    }

    #[test]
    fn test_generate_main_rs() {
        let temp_dir = TempDir::new().unwrap();
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();
        let project_name = "test-main";

        let result = generate_main_rs(project_name, &src_dir);
        assert!(result.is_ok());

        let main_rs = fs::read_to_string(src_dir.join("main.rs")).unwrap();

        assert!(main_rs.contains("use clap::Parser"));
        assert!(main_rs.contains("use colored::*"));
        assert!(main_rs.contains("use eyre::{Context, Result}"));
        assert!(main_rs.contains("fn main()"));
        assert!(main_rs.contains("fn setup_logging()"));
        assert!(main_rs.contains("fn run_application"));
        assert!(main_rs.contains(project_name));
        assert!(main_rs.contains("mod cli"));
        assert!(main_rs.contains("mod config"));
    }

    #[test]
    fn test_generate_cli_rs() {
        let temp_dir = TempDir::new().unwrap();
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();
        let project_name = "test-cli";

        let result = generate_cli_rs(project_name, &src_dir);
        assert!(result.is_ok());

        let cli_rs = fs::read_to_string(src_dir.join("cli.rs")).unwrap();

        assert!(cli_rs.contains("use clap::Parser"));
        assert!(cli_rs.contains("#[derive(Parser)]"));
        assert!(cli_rs.contains(&format!("name = \"{}\"", project_name)));
        assert!(cli_rs.contains("pub struct Cli"));
        assert!(cli_rs.contains("pub config: Option<PathBuf>"));
        assert!(cli_rs.contains("pub verbose: bool"));
        assert!(cli_rs.contains("A CLI application generated by rust-scaffold"));
        assert!(cli_rs.contains(&format!("~/.local/share/{}/logs/{}.log", project_name, project_name)));
    }

    #[test]
    fn test_generate_config_rs() {
        let temp_dir = TempDir::new().unwrap();
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();

        let result = generate_config_rs(&src_dir);
        assert!(result.is_ok());

        let config_rs = fs::read_to_string(src_dir.join("config.rs")).unwrap();

        assert!(config_rs.contains("use serde::{Deserialize, Serialize}"));
        assert!(config_rs.contains("pub struct Config"));
        assert!(config_rs.contains("pub name: String"));
        assert!(config_rs.contains("pub age: u32"));
        assert!(config_rs.contains("pub debug: bool"));
        assert!(config_rs.contains("impl Default for Config"));
        assert!(config_rs.contains("pub fn load"));
        assert!(config_rs.contains("fn load_from_file"));
        assert!(config_rs.contains("John Doe"));
    }

    #[test]
    fn test_generate_sample_config() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-sample";

        let result = generate_sample_config(project_name, temp_dir.path());
        assert!(result.is_ok());

        let config_file = temp_dir.path().join(format!("{}.yml", project_name));
        assert!(config_file.exists());

        let config_content = fs::read_to_string(&config_file).unwrap();

        assert!(config_content.contains(project_name));
        assert!(config_content.contains("name: \"John Doe\""));
        assert!(config_content.contains("age: 30"));
        assert!(config_content.contains("debug: false"));
        assert!(config_content.contains("Sample configuration file"));
    }

    #[test]
    fn test_generate_project_with_different_authors() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-authors";
        let config = create_test_config();

        let authors = [
            "Simple Name",
            "Name With Spaces <email@example.com>",
            "Unicode √Ñuth√∂r <√ºnic√∂de@example.com>",
        ];

        for author in authors.iter() {
            let project_dir = temp_dir.path().join(author.replace(['<', '>', '@', ' '], "_"));
            let result = generate_project(project_name, &project_dir, author, &config, false);
            assert!(result.is_ok(), "Failed for author: {}", author);

            let cargo_toml = fs::read_to_string(project_dir.join("Cargo.toml")).unwrap();
            assert!(cargo_toml.contains(author));
        }
    }

    #[test]
    fn test_generate_project_with_special_characters_in_name() {
        let temp_dir = TempDir::new().unwrap();
        let config = create_test_config();
        let author = "Test Author";

        let project_names = ["simple", "with-dashes", "with_underscores", "with123numbers"];

        for project_name in project_names.iter() {
            let project_dir = temp_dir.path().join(project_name);
            let result = generate_project(project_name, &project_dir, author, &config, false);
            assert!(result.is_ok(), "Failed for project name: {}", project_name);

            let cargo_toml = fs::read_to_string(project_dir.join("Cargo.toml")).unwrap();
            assert!(cargo_toml.contains(&format!("name = \"{}\"", project_name)));

            let main_rs = fs::read_to_string(project_dir.join("src/main.rs")).unwrap();
            assert!(main_rs.contains(project_name));

            let cli_rs = fs::read_to_string(project_dir.join("src/cli.rs")).unwrap();
            assert!(cli_rs.contains(&format!("name = \"{}\"", project_name)));

            let sample_config = project_dir.join(format!("{}.yml", project_name));
            assert!(sample_config.exists());
        }
    }

    #[test]
    fn test_generate_project_creates_src_directory() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-src";
        let author = "Test Author";
        let config = create_test_config();

        // Ensure src directory doesn't exist initially
        assert!(!temp_dir.path().join("src").exists());

        let result = generate_project(project_name, temp_dir.path(), author, &config, false);
        assert!(result.is_ok());

        // Verify src directory was created
        assert!(temp_dir.path().join("src").exists());
        assert!(temp_dir.path().join("src").is_dir());
    }
}
