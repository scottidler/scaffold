use eyre::{Context, Result};
use std::fs;
use std::path::PathBuf;
use crate::config::Config;

pub fn generate_project(project_name: &str, target_dir: &PathBuf, author: &str, config: &Config, include_deps: bool) -> Result<()> {
    // Create src directory
    let src_dir = target_dir.join("src");
    fs::create_dir_all(&src_dir)
        .context("Failed to create src directory")?;
    
    // Generate Cargo.toml
    generate_cargo_toml(project_name, target_dir, author, config, include_deps)?;
    
    // Generate build.rs
    generate_build_rs(target_dir)?;
    
    // Generate source files
    generate_main_rs(project_name, &src_dir)?;
    generate_cli_rs(project_name, &src_dir)?;
    generate_config_rs(&src_dir)?;
    
    // Generate sample config file
    generate_sample_config(project_name, target_dir)?;
    
    println!("✓ Generated all project files");
    Ok(())
}

fn generate_cargo_toml(project_name: &str, target_dir: &PathBuf, author: &str, config: &Config, include_deps: bool) -> Result<()> {
    let mut cargo_toml = format!(r#"[package]
name = "{}"
version = "0.1.0"
edition = "2024"
authors = ["{}"]
build = "build.rs"
description = "A CLI application generated by rust-scaffold"

[dependencies]"#, project_name, author);

    if include_deps {
        // Add dependencies directly to Cargo.toml
        for dep in &config.template.dependencies {
            if dep.features.is_empty() {
                cargo_toml.push_str(&format!("\n{} = \"*\"", dep.name));
            } else {
                cargo_toml.push_str(&format!("\n{} = {{ version = \"*\", features = [{}] }}", 
                    dep.name, 
                    dep.features.iter().map(|f| format!("\"{}\"", f)).collect::<Vec<_>>().join(", ")
                ));
            }
        }
    } else {
        cargo_toml.push_str("\n# Dependencies will be added via cargo add");
    }

    cargo_toml.push_str("\n\n[build-dependencies]\n# For build.rs if needed\n");
    
    fs::write(target_dir.join("Cargo.toml"), cargo_toml)
        .context("Failed to write Cargo.toml")?;
    
    Ok(())
}

fn generate_build_rs(target_dir: &PathBuf) -> Result<()> {
    let build_rs = r#"// Simple pattern for git describe -> version
use std::process::Command;

fn main() {
    let git_describe = Command::new("git")
        .args(&["describe", "--tags", "--always"])
        .output()
        .and_then(|output| {
            if output.status.success() {
                Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
            } else {
                Err(std::io::Error::new(std::io::ErrorKind::Other, "git describe failed"))
            }
        })
        .unwrap_or_else(|_| {
            // Fallback to Cargo.toml version when git describe fails
            env!("CARGO_PKG_VERSION").to_string()
        });

    println!("cargo:rustc-env=GIT_DESCRIBE={}", git_describe);
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/");
}
"#;
    
    fs::write(target_dir.join("build.rs"), build_rs)
        .context("Failed to write build.rs")?;
    
    Ok(())
}

fn generate_main_rs(project_name: &str, src_dir: &PathBuf) -> Result<()> {
    let main_rs = format!(r#"use clap::Parser;
use colored::*;
use eyre::{{Context, Result}};
use log::info;
use std::fs;
use std::path::PathBuf;

mod cli;
mod config;

use cli::Cli;
use config::Config;

fn setup_logging() -> Result<()> {{
    // Create log directory
    let log_dir = dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("{}")
        .join("logs");
    
    fs::create_dir_all(&log_dir)
        .context("Failed to create log directory")?;
    
    let log_file = log_dir.join("{}.log");
    
    // Setup env_logger with file output
    let target = Box::new(fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(&log_file)
        .context("Failed to open log file")?);
    
    env_logger::Builder::from_default_env()
        .target(env_logger::Target::Pipe(target))
        .init();
    
    info!("Logging initialized, writing to: {{}}", log_file.display());
    Ok(())
}}

fn run_application(_cli: &Cli, config: &Config) -> Result<()> {{
    info!("Starting application");
    
    // Load and display configuration
    println!("{{}}", "✓ Configuration loaded successfully".green());
    if config.debug {{
        println!("{{}}", "🔍 Debug mode enabled".yellow());
    }}
    
    // Demonstrate colored output
    println!("{{}} Hello from {{}}!", "🎉".green(), "{}".cyan());
    println!("{{}} Author: {{}}", "👤".blue(), config.name);
    println!("{{}} Age: {{}}", "📅".blue(), config.age);
    
    // Log some information
    info!("Application executed successfully");
    
    Ok(())
}}

fn main() -> Result<()> {{
    // Setup logging first
    setup_logging()
        .context("Failed to setup logging")?;
    
    // Parse CLI arguments
    let cli = Cli::parse();
    
    // Load configuration
    let config = Config::load(cli.config.as_ref())
        .context("Failed to load configuration")?;
    
    info!("Starting with config from: {{:?}}", cli.config);
    
    // Run the main application logic
    run_application(&cli, &config)
        .context("Application failed")?;
    
    Ok(())
}}
"#, project_name, project_name, project_name);
    
    fs::write(src_dir.join("main.rs"), main_rs)
        .context("Failed to write main.rs")?;
    
    Ok(())
}

fn generate_cli_rs(project_name: &str, src_dir: &PathBuf) -> Result<()> {
    let cli_rs = format!(r#"use clap::Parser;
use std::path::PathBuf;

#[derive(Parser)]
#[command(
    name = "{}",
    about = "A CLI application generated by rust-scaffold",
    version = env!("GIT_DESCRIBE"),
    after_help = "Logs are written to: ~/.local/share/{}/logs/{}.log"
)]
pub struct Cli {{
    /// Path to config file
    #[arg(short, long, help = "Path to config file")]
    pub config: Option<PathBuf>,
    
    /// Enable verbose output
    #[arg(short, long, help = "Enable verbose output")]
    pub verbose: bool,
}}
"#, project_name, project_name, project_name);
    
    fs::write(src_dir.join("cli.rs"), cli_rs)
        .context("Failed to write cli.rs")?;
    
    Ok(())
}

fn generate_config_rs(src_dir: &PathBuf) -> Result<()> {
    let config_rs = r#"use eyre::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Deserialize, Serialize)]
#[serde(default)]
pub struct Config {
    pub name: String,
    pub age: u32,
    pub debug: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            name: "John Doe".to_string(),
            age: 30,
            debug: false,
        }
    }
}

impl Config {
    /// Load configuration with fallback chain
    pub fn load(config_path: Option<&PathBuf>) -> Result<Self> {
        // If explicit config path provided, try to load it
        if let Some(path) = config_path {
            return Self::load_from_file(path)
                .context(format!("Failed to load config from {}", path.display()));
        }
        
        // Try primary location: ~/.config/<project>/<project>.yml
        if let Some(config_dir) = dirs::config_dir() {
            let project_name = env!("CARGO_PKG_NAME");
            let primary_config = config_dir.join(project_name).join(format!("{}.yml", project_name));
            if primary_config.exists() {
                match Self::load_from_file(&primary_config) {
                    Ok(config) => return Ok(config),
                    Err(e) => {
                        log::warn!("Failed to load config from {}: {}", primary_config.display(), e);
                    }
                }
            }
        }
        
        // Try fallback location: ./<project>.yml
        let project_name = env!("CARGO_PKG_NAME");
        let fallback_config = PathBuf::from(format!("{}.yml", project_name));
        if fallback_config.exists() {
            match Self::load_from_file(&fallback_config) {
                Ok(config) => return Ok(config),
                Err(e) => {
                    log::warn!("Failed to load config from {}: {}", fallback_config.display(), e);
                }
            }
        }
        
        // No config file found, use defaults
        log::info!("No config file found, using defaults");
        Ok(Self::default())
    }
    
    fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = fs::read_to_string(&path)
            .context("Failed to read config file")?;
        
        let config: Self = serde_yaml::from_str(&content)
            .context("Failed to parse config file")?;
        
        log::info!("Loaded config from: {}", path.as_ref().display());
        Ok(config)
    }
    

}
"#;
    
    fs::write(src_dir.join("config.rs"), config_rs)
        .context("Failed to write config.rs")?;
    
    Ok(())
}

fn generate_sample_config(project_name: &str, target_dir: &PathBuf) -> Result<()> {
    let sample_config = format!(r#"# {}.yml - Sample configuration file
name: "John Doe"
age: 30
debug: false
"#, project_name);
    
    fs::write(target_dir.join(format!("{}.yml", project_name)), sample_config)
        .context("Failed to write sample config")?;
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::fs;

    fn create_test_config() -> Config {
        Config::default()
    }

    #[test]
    fn test_generate_project_creates_all_files() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-project";
        let author = "Test Author <test@example.com>";
        let config = create_test_config();

        let result = generate_project(project_name, &temp_dir.path().to_path_buf(), author, &config, false);
        assert!(result.is_ok());

        // Check that all expected files were created
        assert!(temp_dir.path().join("Cargo.toml").exists());
        assert!(temp_dir.path().join("build.rs").exists());
        assert!(temp_dir.path().join("src").exists());
        assert!(temp_dir.path().join("src/main.rs").exists());
        assert!(temp_dir.path().join("src/cli.rs").exists());
        assert!(temp_dir.path().join("src/config.rs").exists());
        assert!(temp_dir.path().join(format!("{}.yml", project_name)).exists());
    }

    #[test]
    fn test_generate_cargo_toml_basic_structure() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-cargo";
        let author = "Test Author <test@example.com>";
        let config = create_test_config();

        let result = generate_cargo_toml(project_name, &temp_dir.path().to_path_buf(), author, &config, false);
        assert!(result.is_ok());

        let cargo_toml = fs::read_to_string(temp_dir.path().join("Cargo.toml")).unwrap();
        
        assert!(cargo_toml.contains(&format!("name = \"{}\"", project_name)));
        assert!(cargo_toml.contains("version = \"0.1.0\""));
        assert!(cargo_toml.contains("edition = \"2024\""));
        assert!(cargo_toml.contains(author));
        assert!(cargo_toml.contains("build = \"build.rs\""));
        assert!(cargo_toml.contains("[dependencies]"));
        assert!(cargo_toml.contains("[build-dependencies]"));
    }

    #[test]
    fn test_generate_cargo_toml_with_dependencies() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-deps";
        let author = "Test Author";
        let config = create_test_config();

        let result = generate_cargo_toml(project_name, &temp_dir.path().to_path_buf(), author, &config, true);
        assert!(result.is_ok());

        let cargo_toml = fs::read_to_string(temp_dir.path().join("Cargo.toml")).unwrap();
        
        // Check that dependencies are included
        assert!(cargo_toml.contains("clap"));
        assert!(cargo_toml.contains("eyre"));
        assert!(cargo_toml.contains("serde"));
        assert!(cargo_toml.contains("derive"));
    }

    #[test]
    fn test_generate_cargo_toml_without_dependencies() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-no-deps";
        let author = "Test Author";
        let config = create_test_config();

        let result = generate_cargo_toml(project_name, &temp_dir.path().to_path_buf(), author, &config, false);
        assert!(result.is_ok());

        let cargo_toml = fs::read_to_string(temp_dir.path().join("Cargo.toml")).unwrap();
        
        // Check that dependencies comment is included instead
        assert!(cargo_toml.contains("Dependencies will be added via cargo add"));
        assert!(!cargo_toml.contains("clap = "));
        assert!(!cargo_toml.contains("eyre = "));
    }

    #[test]
    fn test_generate_build_rs() {
        let temp_dir = TempDir::new().unwrap();

        let result = generate_build_rs(&temp_dir.path().to_path_buf());
        assert!(result.is_ok());

        let build_rs = fs::read_to_string(temp_dir.path().join("build.rs")).unwrap();
        
        assert!(build_rs.contains("fn main()"));
        assert!(build_rs.contains("git describe"));
        assert!(build_rs.contains("GIT_DESCRIBE"));
        assert!(build_rs.contains("cargo:rerun-if-changed=.git/HEAD"));
        assert!(build_rs.contains("cargo:rerun-if-changed=.git/refs/"));
    }

    #[test]
    fn test_generate_main_rs() {
        let temp_dir = TempDir::new().unwrap();
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();
        let project_name = "test-main";

        let result = generate_main_rs(project_name, &src_dir);
        assert!(result.is_ok());

        let main_rs = fs::read_to_string(src_dir.join("main.rs")).unwrap();
        
        assert!(main_rs.contains("use clap::Parser"));
        assert!(main_rs.contains("use colored::*"));
        assert!(main_rs.contains("use eyre::{Context, Result}"));
        assert!(main_rs.contains("fn main()"));
        assert!(main_rs.contains("fn setup_logging()"));
        assert!(main_rs.contains("fn run_application"));
        assert!(main_rs.contains(project_name));
        assert!(main_rs.contains("mod cli"));
        assert!(main_rs.contains("mod config"));
    }

    #[test]
    fn test_generate_cli_rs() {
        let temp_dir = TempDir::new().unwrap();
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();
        let project_name = "test-cli";

        let result = generate_cli_rs(project_name, &src_dir);
        assert!(result.is_ok());

        let cli_rs = fs::read_to_string(src_dir.join("cli.rs")).unwrap();
        
        assert!(cli_rs.contains("use clap::Parser"));
        assert!(cli_rs.contains("#[derive(Parser)]"));
        assert!(cli_rs.contains(&format!("name = \"{}\"", project_name)));
        assert!(cli_rs.contains("pub struct Cli"));
        assert!(cli_rs.contains("pub config: Option<PathBuf>"));
        assert!(cli_rs.contains("pub verbose: bool"));
        assert!(cli_rs.contains("A CLI application generated by rust-scaffold"));
        assert!(cli_rs.contains(&format!("~/.local/share/{}/logs/{}.log", project_name, project_name)));
    }

    #[test]
    fn test_generate_config_rs() {
        let temp_dir = TempDir::new().unwrap();
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();

        let result = generate_config_rs(&src_dir);
        assert!(result.is_ok());

        let config_rs = fs::read_to_string(src_dir.join("config.rs")).unwrap();
        
        assert!(config_rs.contains("use serde::{Deserialize, Serialize}"));
        assert!(config_rs.contains("pub struct Config"));
        assert!(config_rs.contains("pub name: String"));
        assert!(config_rs.contains("pub age: u32"));
        assert!(config_rs.contains("pub debug: bool"));
        assert!(config_rs.contains("impl Default for Config"));
        assert!(config_rs.contains("pub fn load"));
        assert!(config_rs.contains("fn load_from_file"));
        assert!(config_rs.contains("John Doe"));
    }

    #[test]
    fn test_generate_sample_config() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-sample";

        let result = generate_sample_config(project_name, &temp_dir.path().to_path_buf());
        assert!(result.is_ok());

        let config_file = temp_dir.path().join(format!("{}.yml", project_name));
        assert!(config_file.exists());

        let config_content = fs::read_to_string(&config_file).unwrap();
        
        assert!(config_content.contains(project_name));
        assert!(config_content.contains("name: \"John Doe\""));
        assert!(config_content.contains("age: 30"));
        assert!(config_content.contains("debug: false"));
        assert!(config_content.contains("Sample configuration file"));
    }

    #[test]
    fn test_generate_project_with_different_authors() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-authors";
        let config = create_test_config();

        let authors = [
            "Simple Name",
            "Name With Spaces <email@example.com>",
            "Unicode Äuthör <ünicöde@example.com>",
        ];

        for author in authors.iter() {
            let project_dir = temp_dir.path().join(author.replace(['<', '>', '@', ' '], "_"));
            let result = generate_project(project_name, &project_dir, author, &config, false);
            assert!(result.is_ok(), "Failed for author: {}", author);

            let cargo_toml = fs::read_to_string(project_dir.join("Cargo.toml")).unwrap();
            assert!(cargo_toml.contains(author));
        }
    }

    #[test]
    fn test_generate_project_with_special_characters_in_name() {
        let temp_dir = TempDir::new().unwrap();
        let config = create_test_config();
        let author = "Test Author";

        let project_names = [
            "simple",
            "with-dashes",
            "with_underscores",
            "with123numbers",
        ];

        for project_name in project_names.iter() {
            let project_dir = temp_dir.path().join(project_name);
            let result = generate_project(project_name, &project_dir, author, &config, false);
            assert!(result.is_ok(), "Failed for project name: {}", project_name);

            let cargo_toml = fs::read_to_string(project_dir.join("Cargo.toml")).unwrap();
            assert!(cargo_toml.contains(&format!("name = \"{}\"", project_name)));

            let main_rs = fs::read_to_string(project_dir.join("src/main.rs")).unwrap();
            assert!(main_rs.contains(project_name));

            let cli_rs = fs::read_to_string(project_dir.join("src/cli.rs")).unwrap();
            assert!(cli_rs.contains(&format!("name = \"{}\"", project_name)));

            let sample_config = project_dir.join(format!("{}.yml", project_name));
            assert!(sample_config.exists());
        }
    }

    #[test]
    fn test_generate_project_creates_src_directory() {
        let temp_dir = TempDir::new().unwrap();
        let project_name = "test-src";
        let author = "Test Author";
        let config = create_test_config();

        // Ensure src directory doesn't exist initially
        assert!(!temp_dir.path().join("src").exists());

        let result = generate_project(project_name, &temp_dir.path().to_path_buf(), author, &config, false);
        assert!(result.is_ok());

        // Verify src directory was created
        assert!(temp_dir.path().join("src").exists());
        assert!(temp_dir.path().join("src").is_dir());
    }
} 