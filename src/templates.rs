use eyre::{Context, Result};
use std::fs;
use std::path::PathBuf;


pub fn generate_project(project_name: &str, target_dir: &PathBuf, author: &str) -> Result<()> {
    // Create src directory
    let src_dir = target_dir.join("src");
    fs::create_dir_all(&src_dir)
        .context("Failed to create src directory")?;
    
    // Generate Cargo.toml
    generate_cargo_toml(project_name, target_dir, author)?;
    
    // Generate build.rs
    generate_build_rs(target_dir)?;
    
    // Generate source files
    generate_main_rs(project_name, &src_dir)?;
    generate_cli_rs(project_name, &src_dir)?;
    generate_config_rs(&src_dir)?;
    
    // Generate sample config file
    generate_sample_config(project_name, target_dir)?;
    
    println!("✓ Generated all project files");
    Ok(())
}

fn generate_cargo_toml(project_name: &str, target_dir: &PathBuf, author: &str) -> Result<()> {
    let cargo_toml = format!(r#"[package]
name = "{}"
version = "0.1.0"
edition = "2024"
authors = ["{}"]
build = "build.rs"
description = "A CLI application generated by rust-scaffold"

[dependencies]
# Dependencies will be added via cargo add

[build-dependencies]
# For build.rs if needed
"#, project_name, author);
    
    fs::write(target_dir.join("Cargo.toml"), cargo_toml)
        .context("Failed to write Cargo.toml")?;
    
    Ok(())
}

fn generate_build_rs(target_dir: &PathBuf) -> Result<()> {
    let build_rs = r#"// Simple pattern for git describe -> version
use std::process::Command;

fn main() {
    let git_describe = Command::new("git")
        .args(&["describe", "--tags", "--always"])
        .output()
        .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
        .unwrap_or_else(|_| "unknown".to_string());

    println!("cargo:rustc-env=GIT_DESCRIBE={}", git_describe);
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/");
}
"#;
    
    fs::write(target_dir.join("build.rs"), build_rs)
        .context("Failed to write build.rs")?;
    
    Ok(())
}

fn generate_main_rs(project_name: &str, src_dir: &PathBuf) -> Result<()> {
    let main_rs = format!(r#"use clap::Parser;
use colored::*;
use eyre::{{Context, Result}};
use log::info;
use std::fs;
use std::path::PathBuf;

mod cli;
mod config;

use cli::Cli;
use config::Config;

fn setup_logging() -> Result<()> {{
    // Create log directory
    let log_dir = dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("{}")
        .join("logs");
    
    fs::create_dir_all(&log_dir)
        .context("Failed to create log directory")?;
    
    let log_file = log_dir.join("{}.log");
    
    // Setup env_logger with file output
    let target = Box::new(fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(&log_file)
        .context("Failed to open log file")?);
    
    env_logger::Builder::from_default_env()
        .target(env_logger::Target::Pipe(target))
        .init();
    
    info!("Logging initialized, writing to: {{}}", log_file.display());
    Ok(())
}}

fn run_application(_cli: &Cli, config: &Config) -> Result<()> {{
    info!("Starting application");
    
    // Load and display configuration
    println!("{{}}", "✓ Configuration loaded successfully".green());
    if config.debug {{
        println!("{{}}", "🔍 Debug mode enabled".yellow());
    }}
    
    // Demonstrate colored output
    println!("{{}} Hello from {{}}!", "🎉".green(), "{}".cyan());
    println!("{{}} Author: {{}}", "👤".blue(), config.name);
    println!("{{}} Age: {{}}", "📅".blue(), config.age);
    
    // Log some information
    info!("Application executed successfully");
    
    Ok(())
}}

fn main() -> Result<()> {{
    // Setup logging first
    setup_logging()
        .context("Failed to setup logging")?;
    
    // Parse CLI arguments
    let cli = Cli::parse();
    
    // Load configuration
    let config = Config::load(cli.config.as_ref())
        .context("Failed to load configuration")?;
    
    info!("Starting with config from: {{:?}}", cli.config);
    
    // Run the main application logic
    run_application(&cli, &config)
        .context("Application failed")?;
    
    Ok(())
}}
"#, project_name, project_name, project_name);
    
    fs::write(src_dir.join("main.rs"), main_rs)
        .context("Failed to write main.rs")?;
    
    Ok(())
}

fn generate_cli_rs(project_name: &str, src_dir: &PathBuf) -> Result<()> {
    let cli_rs = format!(r#"use clap::Parser;
use std::path::PathBuf;

#[derive(Parser)]
#[command(
    name = "{}",
    about = "A CLI application generated by rust-scaffold",
    version = env!("GIT_DESCRIBE"),
    after_help = "Logs are written to: ~/.local/share/{}/logs/{}.log"
)]
pub struct Cli {{
    /// Path to config file
    #[arg(short, long, help = "Path to config file")]
    pub config: Option<PathBuf>,
    
    /// Enable verbose output
    #[arg(short, long, help = "Enable verbose output")]
    pub verbose: bool,
}}
"#, project_name, project_name, project_name);
    
    fs::write(src_dir.join("cli.rs"), cli_rs)
        .context("Failed to write cli.rs")?;
    
    Ok(())
}

fn generate_config_rs(src_dir: &PathBuf) -> Result<()> {
    let config_rs = r#"use eyre::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Deserialize, Serialize)]
#[serde(default)]
pub struct Config {
    pub name: String,
    pub age: u32,
    pub debug: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            name: "John Doe".to_string(),
            age: 30,
            debug: false,
        }
    }
}

impl Config {
    /// Load configuration with fallback chain
    pub fn load(config_path: Option<&PathBuf>) -> Result<Self> {
        // If explicit config path provided, try to load it
        if let Some(path) = config_path {
            return Self::load_from_file(path)
                .context(format!("Failed to load config from {}", path.display()));
        }
        
        // Try primary location: ~/.config/<project>/<project>.yml
        if let Some(config_dir) = dirs::config_dir() {
            let project_name = env!("CARGO_PKG_NAME");
            let primary_config = config_dir.join(project_name).join(format!("{}.yml", project_name));
            if primary_config.exists() {
                match Self::load_from_file(&primary_config) {
                    Ok(config) => return Ok(config),
                    Err(e) => {
                        log::warn!("Failed to load config from {}: {}", primary_config.display(), e);
                    }
                }
            }
        }
        
        // Try fallback location: ./<project>.yml
        let project_name = env!("CARGO_PKG_NAME");
        let fallback_config = PathBuf::from(format!("{}.yml", project_name));
        if fallback_config.exists() {
            match Self::load_from_file(&fallback_config) {
                Ok(config) => return Ok(config),
                Err(e) => {
                    log::warn!("Failed to load config from {}: {}", fallback_config.display(), e);
                }
            }
        }
        
        // No config file found, use defaults
        log::info!("No config file found, using defaults");
        Ok(Self::default())
    }
    
    fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = fs::read_to_string(&path)
            .context("Failed to read config file")?;
        
        let config: Self = serde_yaml::from_str(&content)
            .context("Failed to parse config file")?;
        
        log::info!("Loaded config from: {}", path.as_ref().display());
        Ok(config)
    }
    

}
"#;
    
    fs::write(src_dir.join("config.rs"), config_rs)
        .context("Failed to write config.rs")?;
    
    Ok(())
}

fn generate_sample_config(project_name: &str, target_dir: &PathBuf) -> Result<()> {
    let sample_config = format!(r#"# {}.yml - Sample configuration file
name: "John Doe"
age: 30
debug: false
"#, project_name);
    
    fs::write(target_dir.join(format!("{}.yml", project_name)), sample_config)
        .context("Failed to write sample config")?;
    
    Ok(())
} 