use assert_cmd::Command;
use predicates::prelude::*;
use serial_test::serial;
use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;

/// Helper to create scaffold command
fn scaffold_cmd() -> Command {
    Command::cargo_bin("scaffold").expect("Failed to find scaffold binary")
}

/// Helper to run cargo command in a directory
fn cargo_cmd_in_dir(dir: &PathBuf, args: &[&str]) -> std::process::Output {
    std::process::Command::new("cargo")
        .args(args)
        .current_dir(dir)
        .output()
        .expect("Failed to run cargo command")
}

/// Comprehensive end-to-end test that creates a project and verifies all functionality
#[test]
#[serial]
fn test_complete_project_lifecycle() {
    let temp_dir = TempDir::new().unwrap();
    let project_name = "e2e-test-project";
    let project_path = temp_dir.path().join(project_name);
    let author = "E2E Test Author <e2e@test.com>";
    
    // Step 1: Create the project
    scaffold_cmd()
        .arg(project_name)
        .arg("--directory")
        .arg(&project_path)
        .arg("--author")
        .arg(author)
        .assert()
        .success()
        .stdout(predicate::str::contains("Project e2e-test-project created successfully"));
    
    // Step 2: Verify all expected files exist
    assert!(project_path.exists());
    assert!(project_path.join("Cargo.toml").exists());
    assert!(project_path.join("build.rs").exists());
    assert!(project_path.join("src").exists());
    assert!(project_path.join("src/main.rs").exists());
    assert!(project_path.join("src/cli.rs").exists());
    assert!(project_path.join("src/config.rs").exists());
    assert!(project_path.join(format!("{}.yml", project_name)).exists());
    assert!(project_path.join(".git").exists());
    
    // Step 3: Verify Cargo.toml content
    let cargo_toml = fs::read_to_string(project_path.join("Cargo.toml")).unwrap();
    assert!(cargo_toml.contains(&format!("name = \"{}\"", project_name)));
    assert!(cargo_toml.contains(author));
    assert!(cargo_toml.contains("edition = \"2024\""));
    
    // Step 4: Verify the project builds
    let build_output = cargo_cmd_in_dir(&project_path, &["build"]);
    assert!(build_output.status.success(), 
            "Build failed: {}", String::from_utf8_lossy(&build_output.stderr));
    
    // Step 5: Test --help command
    let help_output = cargo_cmd_in_dir(&project_path, &["run", "--", "--help"]);
    assert!(help_output.status.success());
    let help_text = String::from_utf8_lossy(&help_output.stdout);
    assert!(help_text.contains(project_name));
    assert!(help_text.contains("A CLI application generated by rust-scaffold"));
    assert!(help_text.contains("--config"));
    assert!(help_text.contains("--verbose"));
    assert!(help_text.contains(&format!("~/.local/share/{}/logs/{}.log", project_name, project_name)));
    
    // Step 6: Test --version command
    let version_output = cargo_cmd_in_dir(&project_path, &["run", "--", "--version"]);
    assert!(version_output.status.success());
    let version_text = String::from_utf8_lossy(&version_output.stdout);
    assert!(version_text.contains(project_name));
    
    // Step 7: Test default execution
    let run_output = cargo_cmd_in_dir(&project_path, &["run"]);
    assert!(run_output.status.success());
    let run_text = String::from_utf8_lossy(&run_output.stdout);
    assert!(run_text.contains("Configuration loaded successfully"));
    assert!(run_text.contains("Hello from"));
    assert!(run_text.contains("John Doe")); // Default config
    assert!(run_text.contains("30")); // Default age
    
    // Step 8: Test with modified config
    let config_file = project_path.join(format!("{}.yml", project_name));
    let custom_config = r#"name: "Custom User"
age: 42
debug: true"#;
    fs::write(&config_file, custom_config).unwrap();
    
    let custom_run_output = cargo_cmd_in_dir(&project_path, &["run"]);
    assert!(custom_run_output.status.success());
    let custom_run_text = String::from_utf8_lossy(&custom_run_output.stdout);
    assert!(custom_run_text.contains("Custom User"));
    assert!(custom_run_text.contains("42"));
    assert!(custom_run_text.contains("Debug mode enabled"));
    
    // Step 9: Test with explicit config file
    let explicit_config = temp_dir.path().join("explicit-config.yml");
    let explicit_config_content = r#"name: "Explicit User"
age: 99
debug: false"#;
    fs::write(&explicit_config, explicit_config_content).unwrap();
    
    let explicit_run_output = cargo_cmd_in_dir(&project_path, 
        &["run", "--", "--config", &explicit_config.to_string_lossy()]);
    assert!(explicit_run_output.status.success());
    let explicit_run_text = String::from_utf8_lossy(&explicit_run_output.stdout);
    assert!(explicit_run_text.contains("Explicit User"));
    assert!(explicit_run_text.contains("99"));
    assert!(!explicit_run_text.contains("Debug mode enabled"));
    
    // Step 10: Test verbose flag
    let verbose_output = cargo_cmd_in_dir(&project_path, &["run", "--", "--verbose"]);
    assert!(verbose_output.status.success());
    
    // Step 11: Verify git repository is properly initialized
    let git_status_output = std::process::Command::new("git")
        .args(&["status"])
        .current_dir(&project_path)
        .output()
        .unwrap();
    assert!(git_status_output.status.success());
}

#[test]
#[serial]
fn test_project_with_all_flags() {
    let temp_dir = TempDir::new().unwrap();
    let project_name = "flags-test";
    let project_path = temp_dir.path().join(project_name);
    let author = "Flags Author <flags@test.com>";
    
    // Create project with all flags
    scaffold_cmd()
        .arg(project_name)
        .arg("--directory")
        .arg(&project_path)
        .arg("--author")
        .arg(author)
        .arg("--no-git")
        .arg("--no-sample-config")
        .assert()
        .success();
    
    // Verify no git repo
    assert!(!project_path.join(".git").exists());
    
    // Verify no sample config (this flag isn't implemented yet, but testing the CLI accepts it)
    // The sample config will still be created since we haven't implemented this flag yet
    
    // Verify project still builds and runs
    let build_output = cargo_cmd_in_dir(&project_path, &["build"]);
    assert!(build_output.status.success());
    
    let run_output = cargo_cmd_in_dir(&project_path, &["run"]);
    assert!(run_output.status.success());
}

#[test]
#[serial]
fn test_project_with_custom_config_file() {
    let temp_dir = TempDir::new().unwrap();
    let project_name = "config-test";
    let project_path = temp_dir.path().join(project_name);
    
    // Create custom scaffold config
    let custom_scaffold_config = temp_dir.path().join("custom-scaffold.yml");
    let config_content = r#"
default_author: "Custom Scaffold Author <custom@scaffold.com>"
default_license: "Apache-2.0"
create_git_repo: false
create_sample_config: true
debug: true
template:
  create_build_rs: true
  create_cli_module: true
  create_config_module: true
  dependencies:
    - name: "clap"
      features: ["derive"]
    - name: "eyre"
    - name: "log"
    - name: "env_logger"
    - name: "serde"
      features: ["derive"]
    - name: "serde_yaml"
    - name: "dirs"
    - name: "colored"
  sample_config:
    name: "Config Generated User"
    age: 77
    debug: true
  cli:
    after_help: "Custom after help text for generated project"
"#;
    fs::write(&custom_scaffold_config, config_content).unwrap();
    
    // Create project with custom config
    scaffold_cmd()
        .arg(project_name)
        .arg("--directory")
        .arg(&project_path)
        .arg("--config")
        .arg(&custom_scaffold_config)
        .assert()
        .success();
    
    // Verify custom author was used
    let cargo_toml = fs::read_to_string(project_path.join("Cargo.toml")).unwrap();
    assert!(cargo_toml.contains("Custom Scaffold Author"));
    
    // Verify no git repo (from config)
    assert!(!project_path.join(".git").exists());
    
    // Verify custom sample config values
    let sample_config = fs::read_to_string(project_path.join(format!("{}.yml", project_name))).unwrap();
    assert!(sample_config.contains("Config Generated User"));
    assert!(sample_config.contains("77"));
    assert!(sample_config.contains("debug: true"));
    
    // Verify project builds and runs with custom config
    let build_output = cargo_cmd_in_dir(&project_path, &["build"]);
    assert!(build_output.status.success());
    
    let run_output = cargo_cmd_in_dir(&project_path, &["run"]);
    assert!(run_output.status.success());
    let run_text = String::from_utf8_lossy(&run_output.stdout);
    assert!(run_text.contains("Config Generated User"));
    assert!(run_text.contains("77"));
    assert!(run_text.contains("Debug mode enabled"));
}

#[test]
#[serial]
fn test_multiple_projects_isolation() {
    let temp_dir = TempDir::new().unwrap();
    let projects = ["isolation-1", "isolation-2", "isolation-3"];
    let authors = [
        "Author One <one@test.com>",
        "Author Two <two@test.com>", 
        "Author Three <three@test.com>"
    ];
    
    let mut project_paths = Vec::new();
    
    // Create multiple projects
    for (project, author) in projects.iter().zip(authors.iter()) {
        let project_path = temp_dir.path().join(project);
        project_paths.push(project_path.clone());
        
        scaffold_cmd()
            .arg(project)
            .arg("--directory")
            .arg(&project_path)
            .arg("--author")
            .arg(author)
            .assert()
            .success();
    }
    
    // Verify each project is independent and works
    for (i, (project, author)) in projects.iter().zip(authors.iter()).enumerate() {
        let project_path = &project_paths[i];
        
        // Verify correct author
        let cargo_toml = fs::read_to_string(project_path.join("Cargo.toml")).unwrap();
        assert!(cargo_toml.contains(author));
        assert!(cargo_toml.contains(&format!("name = \"{}\"", project)));
        
        // Verify project builds
        let build_output = cargo_cmd_in_dir(project_path, &["build"]);
        assert!(build_output.status.success(), 
                "Project {} failed to build", project);
        
        // Verify project runs
        let run_output = cargo_cmd_in_dir(project_path, &["run"]);
        assert!(run_output.status.success(),
                "Project {} failed to run", project);
        
        // Verify help shows correct project name
        let help_output = cargo_cmd_in_dir(project_path, &["run", "--", "--help"]);
        assert!(help_output.status.success());
        let help_text = String::from_utf8_lossy(&help_output.stdout);
        assert!(help_text.contains(project));
    }
}

#[test]
#[serial]
fn test_generated_project_error_handling() {
    let temp_dir = TempDir::new().unwrap();
    let project_name = "error-test";
    let project_path = temp_dir.path().join(project_name);
    
    scaffold_cmd()
        .arg(project_name)
        .arg("--directory")
        .arg(&project_path)
        .assert()
        .success();
    
    // Test invalid config file
    let invalid_config = temp_dir.path().join("invalid.yml");
    fs::write(&invalid_config, "invalid: yaml: content: [").unwrap();
    
    let error_output = cargo_cmd_in_dir(&project_path, 
        &["run", "--", "--config", &invalid_config.to_string_lossy()]);
    assert!(!error_output.status.success());
    let error_text = String::from_utf8_lossy(&error_output.stderr);
    assert!(error_text.contains("Failed to load configuration") || 
            error_text.contains("Failed to parse config"));
    
    // Test non-existent config file
    let nonexistent_config = temp_dir.path().join("nonexistent.yml");
    let nonexistent_output = cargo_cmd_in_dir(&project_path,
        &["run", "--", "--config", &nonexistent_config.to_string_lossy()]);
    assert!(!nonexistent_output.status.success());
}

#[test]
#[serial]
fn test_generated_project_dependencies() {
    let temp_dir = TempDir::new().unwrap();
    let project_name = "deps-test";
    let project_path = temp_dir.path().join(project_name);
    
    scaffold_cmd()
        .arg(project_name)
        .arg("--directory")
        .arg(&project_path)
        .assert()
        .success();
    
    // Read Cargo.toml and verify all expected dependencies
    let cargo_toml = fs::read_to_string(project_path.join("Cargo.toml")).unwrap();
    
    let expected_deps = [
        "clap", "eyre", "log", "env_logger", 
        "serde", "serde_yaml", "dirs", "colored"
    ];
    
    for dep in expected_deps.iter() {
        assert!(cargo_toml.contains(dep), "Missing dependency: {}", dep);
    }
    
    // Verify the project builds (which confirms all dependencies are valid)
    let build_output = cargo_cmd_in_dir(&project_path, &["build"]);
    assert!(build_output.status.success(),
            "Build failed, dependencies may be incorrect: {}", 
            String::from_utf8_lossy(&build_output.stderr));
}

#[test]
#[serial]
fn test_generated_project_logging() {
    let temp_dir = TempDir::new().unwrap();
    let project_name = "logging-test";
    let project_path = temp_dir.path().join(project_name);
    
    scaffold_cmd()
        .arg(project_name)
        .arg("--directory")
        .arg(&project_path)
        .assert()
        .success();
    
    // Run the project to trigger logging setup
    let run_output = cargo_cmd_in_dir(&project_path, &["run"]);
    assert!(run_output.status.success());
    
    // Check that main.rs contains proper logging setup
    let main_rs = fs::read_to_string(project_path.join("src/main.rs")).unwrap();
    assert!(main_rs.contains("env_logger::Builder"));
    assert!(main_rs.contains("setup_logging"));
    assert!(main_rs.contains(&format!(".join(\"{}\")", project_name)));
    assert!(main_rs.contains("info!("));
    
    // Check that CLI help mentions log location
    let help_output = cargo_cmd_in_dir(&project_path, &["run", "--", "--help"]);
    let help_text = String::from_utf8_lossy(&help_output.stdout);
    assert!(help_text.contains(&format!("~/.local/share/{}/logs/{}.log", project_name, project_name)));
} 