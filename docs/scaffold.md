# Rust CLI Project Scaffolding Tool - Design Document

## Overview

This document outlines the design for a dedicated Rust CLI project scaffolding tool that generates complete, production-ready Rust CLI applications with best practices, proper error handling, logging, configuration management, and modern tooling.

## Background & Analysis

Based on comprehensive analysis of existing Rust CLI projects (`rkvr`, `manifest`, `otto`, `aka`, `slam`, `aws-tools`, `git-tools`), we identified consistent patterns and best practices that should be codified into a reusable template system.

### Key Findings from Project Analysis

#### Common Dependencies (100% adoption):
- `clap` with `derive` features for CLI parsing
- `eyre` for error handling (no `thiserror`, no `dyn Error`, no `unwrap()`)
- `serde` with `derive` features for configuration
- `serde_yaml` for YAML config files
- `log` for structured logging

#### Logging Patterns:
- **Standard approach**: `env_logger` with custom file output (70% of projects)
- **Advanced approach**: `fern` for dual console+file output (30% of projects)
- **Best practice**: Log to `~/.local/share/<project>/logs/<project>.log`
- **Default level**: INFO, with RUST_LOG environment variable override support
- **Log location displayed**: In CLI `after_help` section

#### Build System Patterns:
Two distinct approaches identified:

1. **Simple Pattern** (recommended):
   ```rust
   // build.rs - creates git_describe.rs in OUT_DIR
   include!(concat!(env!("OUT_DIR"), "/git_describe.rs"));
   ```

2. **Advanced Pattern**:
   ```rust
   // build.rs - uses cargo:rustc-env
   env!("GIT_DESCRIBE")
   ```

#### Configuration Management:
- **Primary location**: `~/.config/<project>/<project>.yml`
- **Fallback locations**: `./<project>.yml` (useful for testing)
- **Structure**: Strongly typed with `#[serde(default)]` attributes
- **Loading**: Graceful fallback chain with proper error handling

#### Project Structure:
```
<project>/
├── Cargo.toml
├── build.rs
├── <project>.yml          # Sample config file
└── src/
    ├── main.rs            # Entry point, logging setup
    ├── cli.rs             # Clap definitions
    └── config.rs          # Configuration structures
```

#### CLI Architecture:
- **Derive-based clap**: `#[derive(Parser)]` pattern
- **Version from git**: All projects use `git describe --tags`
- **Config file support**: `-c|--config` flag standard
- **Help sections**: `after_help` shows log file location
- **No subcommands**: Keep initial template simple

#### Error Handling Standards:
- `eyre::Result<()>` return type for all functions
- `eyre::Context` for error context
- Proper error propagation with `?` operator
- No `unwrap()` calls anywhere in codebase
- Graceful handling of missing files, permissions, etc.

## Tool Requirements

### Core Functionality
The scaffolding tool should generate a complete, working Rust CLI project that:

1. **Builds successfully** with `cargo build`
2. **Runs immediately** with basic "hello world" functionality
3. **Demonstrates all features**: config loading, logging, error handling
4. **Follows best practices** identified from existing projects
5. **Uses latest crate versions** via `cargo add` (no static versions)

### Generated Project Features

#### Dependencies (added via `cargo add`):
```bash
cargo add clap --features derive
cargo add eyre
cargo add log
cargo add env_logger
cargo add serde --features derive
cargo add serde_yaml
cargo add dirs
cargo add colored
```

#### Build System:
- **build.rs**: Simple pattern that captures git tag version
- **Version display**: `--version` shows git describe output
- **Rerun triggers**: Proper cargo rerun directives

#### Logging System:
- **Library**: `env_logger` (chosen for simplicity over `fern`)
- **Default level**: INFO
- **Environment override**: `RUST_LOG` support
- **File output**: `~/.local/share/<project>/logs/<project>.log`
- **Directory creation**: Automatic log directory creation
- **Help display**: Log file location in `after_help`

#### Configuration System:
- **Primary location**: `~/.config/<project>/<project>.yml`
- **Fallback location**: `./<project>.yml`
- **Sample config**: Generated with example fields
- **CLI override**: `-c|--config <PATH>` flag
- **Error handling**: Graceful missing file handling

#### CLI Interface:
```rust
#[derive(Parser)]
#[command(
    name = "<project>",
    about = "A CLI application generated by rust-scaffold",
    version = env!("GIT_DESCRIBE"),
    after_help = "Logs are written to: ~/.local/share/<project>/logs/<project>.log"
)]
struct Cli {
    #[arg(short, long, help = "Path to config file")]
    config: Option<PathBuf>,
    
    // Additional args as needed
}
```

#### Sample Configuration:
```yaml
# <project>.yml
name: "John Doe"
age: 30
debug: false
```

#### Hello World Functionality:
The generated project should demonstrate:
- Config file loading and parsing
- Colored output using `colored` crate
- Proper error handling and logging
- All systems working together

### Project Structure Template

#### Cargo.toml:
```toml
[package]
name = "<project>"
version = "0.1.0"
edition = "2021"
authors = ["<author>"]
build = "build.rs"

[dependencies]
# Dependencies added via cargo add - no static versions

[build-dependencies]
# For build.rs if needed
```

#### build.rs:
```rust
// Simple pattern for git describe -> version
use std::process::Command;

fn main() {
    let git_describe = Command::new("git")
        .args(&["describe", "--tags", "--always"])
        .output()
        .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
        .unwrap_or_else(|_| "unknown".to_string());

    println!("cargo:rustc-env=GIT_DESCRIBE={}", git_describe);
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/");
}
```

#### src/main.rs:
- Logging setup with file output
- CLI parsing with clap
- Config loading with fallback
- Error handling with eyre
- Colored output demonstration

#### src/cli.rs:
- Clap derive structures
- Command definitions
- Help text and version info

#### src/config.rs:
- Serde structures for configuration
- Loading functions with fallback logic
- Default value handling

## Scaffolding Tool Design

### Tool Name: `rust-scaffold`

### CLI Interface:
```bash
rust-scaffold <project-name> [options]

Options:
  -a, --author <AUTHOR>     Author name for Cargo.toml
  -d, --directory <DIR>     Target directory (default: ./<project-name>)
  --no-git                  Don't initialize git repository
  --no-sample-config        Don't create sample config file
```

### Operation Flow:
1. **Validate inputs**: Check project name, target directory
2. **Create project directory**: `mkdir <project-name>`
3. **Generate Cargo.toml**: With proper metadata
4. **Create src/ directory**: With all source files
5. **Generate build.rs**: With git describe functionality
6. **Create sample config**: `<project>.yml` in project root
7. **Initialize git** (unless --no-git): `git init`
8. **Run cargo add**: Add all dependencies with latest versions
9. **Verify build**: Ensure `cargo build` succeeds
10. **Display success message**: With next steps

### Error Handling:
- **Directory exists**: Prompt for overwrite or fail gracefully
- **Git not available**: Warn but continue
- **Cargo not available**: Fatal error with helpful message
- **Permission issues**: Clear error messages
- **Network issues**: Handle cargo add failures gracefully

### Output Messages:
- **Colored output**: Success in green, warnings in yellow, errors in red
- **Progress indicators**: Show what's being created
- **Final instructions**: How to build and run the generated project

## Implementation Requirements

### Dependencies for Scaffolding Tool:
```bash
cargo add clap --features derive
cargo add eyre
cargo add colored
cargo add serde --features derive
cargo add serde_yaml
cargo add dirs
```

### File Templates:
All source file templates should be embedded in the scaffolding tool as string constants or included via `include_str!()` macro.

### Template Variables:
- `{{PROJECT_NAME}}`: Project name
- `{{AUTHOR}}`: Author name
- `{{PROJECT_NAME_UPPER}}`: Uppercase project name
- `{{PROJECT_NAME_LOWER}}`: Lowercase project name

### Testing Strategy:
- **Unit tests**: Template generation functions
- **Integration tests**: Full project generation and build verification
- **Temporary directories**: Use `tempfile` crate for test isolation

## Success Criteria

A successful implementation should:

1. **Generate working projects**: `cargo build && cargo run` succeeds immediately
2. **Follow best practices**: All patterns from analysis implemented
3. **Handle edge cases**: Existing directories, missing tools, etc.
4. **Provide clear feedback**: Users know what's happening and what to do next
5. **Be maintainable**: Easy to update templates and add features

## Future Enhancements

Potential future features (not in initial scope):
- **Multiple templates**: Web service, library, workspace, etc.
- **Interactive mode**: Prompt for configuration options
- **Custom templates**: User-defined template support
- **CI/CD integration**: Generate GitHub Actions workflows
- **Documentation**: Auto-generate README.md

## References

This design is based on analysis of the following projects:
- `rkvr`: Advanced logging with fern, comprehensive error handling
- `manifest`: Modular CLI structure, sophisticated config management
- `otto`: Complex build system, workspace patterns
- `aka`: Clean config loading, simple CLI design
- `slam`: Modern clap patterns, good logging setup
- `aws-tools`: Workspace dependency management
- `git-tools`: Multi-project workspace structure

The scaffolding tool should generate projects that embody the best practices found across these implementations while remaining simple and approachable for new CLI projects. 